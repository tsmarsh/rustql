# GEMINI Project Context: rustql

This document provides essential context for working on the `rustql` codebase. It outlines the project's architecture, key commands, and development workflow.

## 1. Project Overview

**`rustql` is a from-scratch, memory-safe rewrite of the SQLite database engine in Rust.**

The primary goal is to achieve architectural and behavioral parity with the upstream C implementation of SQLite, which is included in the `sqlite3/` directory for reference. The project favors direct, "mechanical" translation of C code to idiomatic Rust over creative refactoring to ensure compatibility.

### Architecture

The project mirrors SQLite's internal layers. A SQL query flows through the following pipeline:

1.  **API Layer:** (`api/`) Public-facing functions like `sqlite3_open`, `sqlite3_prepare_v2`, etc.
2.  **SQL Compiler:**
    *   **Tokenizer & Parser:** (`parser/`) Converts SQL text into an Abstract Syntax Tree (AST).
    *   **Resolver & Code Gen:** (`executor/`) Compiles the AST into a bytecode program.
3.  **Virtual Database Engine (VDBE):** (`vdbe/`) A bytecode interpreter that executes the program generated by the compiler. This is the heart of query execution.
4.  **Storage Engine:**
    *   **B-Tree Layer:** (`storage/`) Manages the B-Tree data structures for tables and indexes.
    *   **Pager Layer:** (`storage/`) Manages the page cache and interaction with the filesystem, including the Write-Ahead Log (WAL).
5.  **OS Abstraction (VFS):** (`os/`) A Virtual File System layer that abstracts platform-specific file operations.

Other important modules include:
*   `functions/`: Built-in scalar and aggregate SQL functions.
*   `schema/`: The in-memory catalog of tables, indexes, and other schema objects.
*   `fts3/`, `rtree.rs`: Partially implemented extensions (Full-Text Search, R-Tree).

## 2. Building and Running

### Building the Code

*   **Standard Build:**
    ```bash
    cargo build
    ```
*   **Release Build:**
    ```bash
    cargo build --release
    ```
*   **Build with all features:** (Needed for some tests)
    ```bash
    cargo build --features "fts3,fts5,rtree,session,json"
    ```
*   **Build the TCL test extension:** (Required for compatibility testing)
    ```bash
    make tcl-extension
    ```

### Running Tests

This project has two main test suites. The primary one is the original TCL test suite from SQLite, which is used to verify compatibility.

*   **Run Rust unit tests:**
    ```bash
    cargo test
    ```

*   **Run SQLite TCL compatibility tests (requires `make tcl-extension` first):**
    *   **Run all major tests in parallel (recommended):**
        ```bash
        make test
        ```
    *   **Run a quick smoke test:**
        ```bash
        make test-basic
        ```
    *   **Run a specific test file (e.g., `select1.test`):**
        ```bash
        make test-select1
        ```
    *   Test results are stored in the `test-results/` directory.

### Code Quality and Formatting

The CI enforces formatting and linting rules.

*   **Check formatting:**
    ```bash
    cargo fmt --check
    ```
*   **Run linter:**
    ```bash
    cargo clippy --all-targets --features fts3,fts5,rtree,session,json
    ```

## 3. Development Conventions

**This project uses a specific workflow designed for multi-agent collaboration. Adhering to it is critical.**

### Core Philosophy

*   **Preserve SQLite's Behavior:** Changes are measured against upstream SQLite behavior. The goal is a faithful port, not a redesign.
*   **Mechanical Translation:** Prefer direct, readable ports of C logic over complex refactors. Keep control flow and error handling aligned with the original C code in `sqlite3/src/`.

### Workflow (`git` + `moth`)

The project uses the `moth` tool to manage tasks and prevent multiple contributors from working on the same issue.

**Always follow this sequence:**

1.  **Sync with remote:**
    ```bash
    git pull
    ```
2.  **See what's available or in progress:**
    ```bash
    # See what's available to work on
    moth ls -t ready

    # See what others are already working on
    moth ls -t doing
    ```
3.  **Claim an issue BEFORE starting to code:**
    ```bash
    moth start {issue-id}
    ```
4.  **Push the status change immediately:** This lets others know you have claimed the task.
    ```bash
    git add .moth/ && git commit -m "[{issue-id}] Started work"
    git push
    ```
5.  **Do the work:** Commit frequently, prefixing your commits with the issue ID.
    ```bash
    git commit -m "[{issue-id}] Implemented feature X"
    git push
    ```
6.  **Mark the task as done:**
    ```bash
    moth done
    ```
7.  **Push the final status change:**
    ```bash
    git add .moth/ && git commit -m "[{issue-id}] Completed"
    git push
    ```

**If you don't follow this workflow, another agent may start the same work, causing merge conflicts and wasted effort.**

## 4. Roles and Responsibilities

### Super BA (Business Analyst) Role

As Super BA, you are responsible for managing the project's task backlog and ensuring work is completed to standard. Your two primary functions are Moth Creation and Moth Verification.

#### Moth Creation (Task Identification)

You are responsible for identifying new work to be done and creating tasks (moths) for the development team. New moths should be actionable and clearly defined.

**To create a new moth:**
```bash
moth new "A clear and concise title for the task" -s {severity}
```
*Severities: `crit` > `high` > `med` > `low`*

**Sources for new moths include:**
*   **Test Failures:** Analyze failing tests in the `test-results/` directory and create moths to fix them.
*   **Functionality Gaps:** Identify features or behaviors present in upstream SQLite but missing from `rustql`.
*   **User Requests:** Address new feature requests or bug reports provided by the user.
*   **Code Quality:** Create tasks for refactoring, addressing tech debt, or improving documentation.

#### Moth Verification (Quality Assurance)

When a developer moves a moth to the `done` state, you are responsible for verifying that the work is truly complete and correct.

**Your verification workflow is:**

1.  **Identify Completed Work:**
    ```bash
    moth ls -t done
    ```
2.  **Review the Task and a developer's work:** For a given `{issue-id}`:
    *   Understand the original goal: `moth show {issue-id}`
    *   Review the code changes: Check `git log` for commits prefixed with `[{issue-id}]`.
3.  **Validate the Solution:**
    *   Run all relevant tests to confirm the fix. If the moth was for `insert`, run `make test-insert`.
    *   Always run the basic test suite as a regression check: `make test-basic` and `cargo test`.
    *   For file format changes, verify compatibility with the `sqlite3` CLI tool.
4.  **Approve or Re-open:**
    *   If the work is complete and correct, the moth can remain in `done`.
    *   If the work is incomplete or incorrect, add a comment to the moth file (`moth edit {issue-id}`) explaining what is missing, and move it back to the `ready` state for another developer to pick up:
        ```bash
        moth mv {issue-id} ready
        ```
